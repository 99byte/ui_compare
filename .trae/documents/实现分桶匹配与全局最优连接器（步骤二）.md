## 目标
在步骤一生成的两份语义图基础上，实现“分区→代价矩阵→全局最优匹配→阈值截断”的连接器，输出干净的配对、缺失与新增集合，为下一步语义级 Diff 提供输入。

## 集成点
- 新增模块：`backend/matcher.py`，实现 `UIFuzzyMatcher`（支持无外部依赖运行）。
- 路由扩展：`/api/compare` 在构建两份语义图后调用匹配器，将结果作为 `matching` 字段加入响应。

## 算法细节
- 预对齐：计算两组节点中心点的 `y` 均值差，匹配计算时临时平移 Runtime 的中心 `y`（不改原数据）。
- 分桶：按 `topology.zone` 将节点分为 `header/body/footer`，仅在同桶内构建代价矩阵。
- 代价矩阵：`Cost = w_geo*C_geo + w_shape*C_shape + w_text*C_text + w_type*C_type`
  - `C_geo`：归一化中心欧氏距离（截顶）+ `(1 - IoU)`（使用归一化 `rel` 坐标）。
  - `C_shape`：宽高比差异（截顶 1.0）。
  - `C_text`：`SequenceMatcher` 相似度的反值，文本有无不一致时置 1.0。
  - `C_type`：查表软惩罚，`{('button','text'),('icon','image'),('input','text')}` 软惩罚，其余硬惩罚。
  - 权重默认：`geo=0.4, shape=0.2, text=0.3, type=0.1`（可配置）。
- 求解：
  - 首选 SciPy `linear_sum_assignment`；
  - 若不可用，采用内置纯 Python 的 Hungarian 实现（矩形矩阵通过高代价填充转方阵）。
- 截断：对最优配对逐对检查，`cost > match_cutoff`（默认 0.65）则断开；设计节点记为 `missing`，运行节点记为 `added`。

## 输出结构
- `matching`: `{ matches: [{design_id,runtime_id,cost}], missing: [design_ids], added: [runtime_ids] }`
- 保持现有响应其余字段以兼容前端，后续逐步迁移到 `diagnostic_report`。

## 验证
- 用本地示例数据验证：按钮文本一致但位置轻微偏移应匹配；新增噪点应进入 `added`；不同形状强制分离。
- 检查各桶匹配数量与阈值截断效果；输出成本值合理分布。

## 后续
- 在步骤三计算详细差异（文本、偏移、尺寸）并聚合报告；分级排序供前端展示。